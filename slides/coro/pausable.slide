Pause-able Parsing and Elegant Interpreters in Go: Using Goroutines as Coroutines
20 September 2016
Tags: zygomys, coroutines, pause-able parsing

Jason E. Aten, Ph.D.
Principal Engineer, Sauce Labs
j.e.aten@gmail.com
@jasonaten_

https://github.com/glycerine/zygomys

[[https://github.com/glycerine/zygomys/wiki.]] The wiki has details, examples, and discussion.

* problem

problem: implementating an interpreter efficiently

- suppose your code is running, and deep inside a nested set of possibly mutually recursive calls...
- and you run out of input.
- ... do you start all over?
- ... and take O(n^2) time to parse an n-line program? Ouch.
- you want to save your state, and resume later, exactly where you left off...
- this is exactly what happens at the interpreter prompt

* start

generally

- how to refactor your straight line code...
- to pause - and - resume gracefully
- to be interuptable
- to be lazy

* benefits

benefits of this style

- more coherency: keep the readability of straight-line code
- insert pause points after the fact
- easier to read => means easier to maintain, refactor, and extend


* context

context: zygomys

- a scripting language
- built in Go, for steering Go
- reflect to invoke compiled Go code
- zygomys has closures with lexical scope
- for loops
- higher order functions.
- eval
- is sandbox-able
- anything inside curly braces {} is infix, to make math readable
.link https://github.com/glycerine/zygomys https://github.com/glycerine/zygomys



* solution

* solution 2

* architecture / overview of design

- a) lexer produces tokens
- b) parser produces lists and arrays of symbols
- c) macros run at definition type
- d) codegen produces s-expression byte-code
- e) (work in progress) builders create and check types at `run` time. (Builders are a hybrid between a function and a macro.)
- f) a simple virtual machine executes s-expression byte-code. User's functions run.

