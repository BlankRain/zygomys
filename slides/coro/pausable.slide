Pause-able Parsing and Elegant Interpreters in Go
Using Goroutines as Coroutines

20 September 2016

Jason E. Aten, Ph.D.
Principal Engineer, Sauce Labs
j.e.aten@gmail.com
@jasonaten_

https://github.com/glycerine/zygomys

[[https://github.com/glycerine/zygomys/wiki.]] The wiki has details, examples, and discussion.

* technical points

- how to refactor your straight line code...
- to pause - and - resume gracefully
- to be interuptable
- to be lazy

* zygomys the scripting language for Go

- supports exploratory data analysis / dynamic reconfiguration with compiled speed.
- so: interactive, but use reflect to call compiled code.
- also aim to eventually compile-down to Go
- blends infix where its more usable (e.g. math readability)
- retains s-expression uniformity for code that generates code

* technically interesting about the zygo implementation:

- using goroutines as coroutines to get pause-able parsing. avoids the O(n^2) trap when reading multi-line user-typed input. Call for more input from many points; inversion of select loop -- exit when you've got another line of input tokens. See repl/parser.go.
- focus of this talk
- also: conditional send technique

* benefits of coroutine style organization

- more coherency: keep the readability of straight-line code
- insert pause points after the fact
- easier to read means easier to maintain, refactor, and extend

* context: the zygomys scripting language

- reflect based calls to existing Go functions (able to use Go structs).-
- full closures with lexical scope
- for-loops, break, continue, optional labels
- eval
- sandbox-able / restrict filesystem access
- higher order functions.

* problem

- suppose your code is running, and deep inside a nested set of possibly recursive calls...
- you run out of input.
- ... do you start all over?
- ... and take O(n^2) time to parse an n line statement?
- ouch.
- this is exactly what happens at the interpreter prompt

* solution

* data model for a plane formation, Go structs

.code ../snoopy1

- note slice of interface / embedded elements (we handle these)

* Methods defined on the Snoopy struct

.code ../snoopy2

- anything that can Fly satisfies the Flyer interface. Weather, informs the Fly event:

.code ../weather

* Flyer friends, can be listed in the Friends slice in Plane

.code ../other.planes

* with the data model in mind, lets interact with it using zygo...

* Make it rain

.code ../make.it.rain

* Bring in some planes, in formation

.code ../make.planes

- in three lines we've instantiated and configured 3 Go structs in a tree

- call a Go method on a Go struct... Snoopy goes Fly()-ing

.code ../plane.interact

* we've just been interacting/scripting Go data and methods...

* yeah, reflection is pretty cool

* zygomys - a scripting toolkit for Go

* zygomys -- what's in a name?

- zygo means union (yoke in Greek; the zygote was the first cell that was you).
- mys means mouse
- this is a little mouse of a language
- bonus: a "pocket gopher" known as Zygogeomys trichopus. Our mascot, "Ziggy".
- this is the union of lisp and Go. In a small cute package. 
- Let's use the shorter `"zygo"` for the language, when speaking aloud.

The Michoacan pocket gopher is a small animal with short, dense, black, lustrous fur... It is docile when caught, making no attempt to bite as do other pocket gophers.
 -- [[https://en.wikipedia.org/wiki/Michoacan_pocket_gopher]]

.image pocket_gopher2.jpeg

* Getting started: How to embed the REPL in your code

See [[https://github.com/glycerine/zygomys/blob/master/cmd/zygo/main.go]]. Just three steps.

.code ../main.go  /START OMIT/,/END OMIT/


* architecture / overview of design

.image pocket_gopher3.jpeg

- a) lexer produces tokens
- b) parser produces lists and arrays of symbols
- c) macros run at definition type
- d) codegen produces s-expression byte-code
- e) (work in progress) builders create and check types at `run` time. (Builders are a hybrid between a function and a macro.)
- f) a simple virtual machine executes s-expression byte-code. User's functions run.


* Let's see some code

- hashmaps can define arbitrary records; with or without attached Go shadow structs

.code ../sample.run1
we range through the hashmap, `hsh`, like this:
.code ../sample.run3


* records

- records are hash tables with a name. All hash tables preserve key-order.

.code ../harry.record

* plain hash maps, without a distinct record TypeName

.code ../hash.demo


* arrays (slices)

.code ../arrays.run



* aims
- interactive, but also aim to eventually compile-down to Go
- blending Go and lisp
- I built it for myself

- technically interesting about the zygo implementation:
- using goroutines as coroutines to get pause-able parsing. avoids the O(n^2) trap. Call for more input from many points; inversion of select loop -- exit when you've got another line of input tokens. See repl/parser.go.
- if you haven't discovered how to do conditional sends on a channel yet, examples inside `github.com/glycerine/zygomys/repl/parser.go`.
   
* hard parts that are already done

- script calls to existing Go functions using existing Go structs. Using reflect is somewhat laborious; but its done
- Go-style for loops, nest-able, with break to label and continue to label.
- eval
- sandbox / restrict filesystem access
- full closures with lexical scope
- adjust lisp syntax to be Go compatible: % for quoting, 'a' for characters.
- higher order functions.

* classic lisp style - list processing

.code ../hof.foldr

- see the closure tests in [[https://github.com/glycerine/zygomys/blob/master/tests/closure.zy]]

* there is also an infix interface

- anything inside curly braces is infix parsed. Can mix in function calls. Math becomes more readable. Uses a Pratt parser.

.code ../infix.session

* inspect the transformation

.code ../infix.txt

* parse tree

.image parseTree.jpg

- hill-climbing: the precedence gets smaller as you go up.
- + addition has precedence 50.
- * multiplication has precedence 60, and so binds more tightly.

* zygo use cases

- as a query language
- configuration language that can query itself.
- Eventually... multi-core friendly scripting. (Channels now, but no select yet).
- Eventually... leverage Go's multicore strength for exploratory configuration, data analysis and scripting. (I love R for productivity, Go for production).
 


* final thoughts

- interpreters teach the value of a test-driven approach
- tests are simply language fragments


* credits
