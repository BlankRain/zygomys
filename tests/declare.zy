;; declare structs
;;
;; and then have the struct definition enforced during type-checking
;; of assignments.

(struct Car [
        (field Id:          int64     e:0                  gotags:`json:"id",name:"id"`)
        (field Name:        string    e:1                  gotags:`json:"name"`)
        (field BadApple:    string    e:2  deprecated:true)
        ])

;; structs can be redefined at the repl
(struct Car [
 (field              Id: int64        e:0       gotags:`json:"id",name:"id"` )
 (field            Name: string       e:1       gotags:`json:"name"`         )
 (field        BadApple: string       e:2   deprecated:true                  )
 (field     SliceOfLife: ([]string)   e:3 )
 (field  PointerSisters: (* int64)    e:4 )
 (field        OtherCar: (* Car)      e:5 )
 ])

(def p (Car Id: 99912))
(def r (Car OtherCar: (& p)))

(assert (==
         (* (& p))
         p
        )
   )

(def p1 (& p))
(def p2 (& p))

(assert (== p1 p2))

(def car2 (Car Id: 7))
(assert (!= (& car2) p1))
(assert (!= (& car2) p2))

(var a (* Car))
(expect-error "Error calling '*': illegal to dereference nil pointer" (assert (== (:Id (* a)) 0)))

(assert (== (type? a) "*Car"))
(a = (& p))
(assert (== (:Id (* a)) 99912))

(hasSlice = (Car SliceOfLife: ["hi" "there"]))
(assert (== (:SliceOfLife hasSlice) ["hi" "there"]))
(assert (== 2 (len (.hasSlice.SliceOfLife))))

(.hasSlice.SliceOfLife = ["zygo" "rocks" "it"])
(assert (== 3 (.hasSlice.SliceOfLife len)))

(expect-error `Error calling '.hasSlice.NewField': Car has no field 'NewField'`
            (.hasSlice.NewField = "wacky"))

(expect-error `Error calling '.hasSlice.SliceOfLife': field Car.SliceOfLife is ([]string), cannot assign ([]int64) '[1 2 3]'`
              (.hasSlice.SliceOfLife = [1 2 3]))


;; nil for slices and pointers should be okay
(Car SliceOfLife:nil)
(Car OtherCar:nil)

;; assignment of [] should work
(.hasSlice.SliceOfLife = [])
(assert (== 0 (len (.hasSlice.SliceOfLife))))

;; we can point to ourselves if need be.
(def w (Car Name: "Willow"))
(.w.OtherCar = (& w))
(assert (== (& w) (:OtherCar w)))
;; or with dot symbol notation:
(assert (== (& w) (.w.OtherCar)))

;; not sure yet how to point to non-records in a persistent fashion.
;; (.w.PointerSisters = (& 34))

;; not yet implemented stuff:

;; delcare functions
;; always using named return types; so we can
;; have an implicit return ending in the compile-down.
;;
;;(func doSomething [a:int b:string] [n:int err:error]
;;  (return a nil))
;;
;; declare interfaces
;; (interface Driveable [
;;      (func driveIt [a:int b:string] [n:int err:error])
;;   ])
;;
;; declare methods
;; (func [p: (* Car)] driveIt [a:int b:string] [n:int err:error])
