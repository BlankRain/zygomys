// infix if and if-else

(assert (== (infixExpand {if 1 == 2 { 3 } else { 4 }})  (quote (quote (cond (== 1 2) (infix [3]) (infix [4]))))))
(assert (== (str (infixExpand {if 1 == 2 { 3 }})) (str (quote (quote (cond (== 1 2) {3} nil))))))

(assert (== (infixExpand { a = 10; b = 12 }) (quote (quote (set a 10) (set b 12)))))

(infixExpand { a = 10; b = 0; if a < 9 { b++ } else { b += 10  }})

(infixExpand { a = 10; b = 0; { if a < 9 { b++ } else { b += 10  }   (assert (== b 10)) }})

// smallest example of the first if-parse problem, now fixed. Semi-colons were not being ignored
// at the end of an expression.
(assert (== (str (infixExpand { a=10; if a < 9 56 })) (str (quote (quote (set a 10) (cond (< a 9) 56 nil))))))

// manually inserting semi-colons will fix the lost-else problem:                              
(assert (== (str (infixExpand { a = 10;  b = 0;  if a < 9 {    b++  } else {    b += 10  } ; (assert (== b 10))  ;  if a > 9 {    b++  };  (assert (== b 11)) })) "(quote (set a 10) (set b 0) (cond (< a 9) (infix [b ++]) (infix [b += 10])) (assert (== b 10)) (cond (> a 9) (infix [b ++]) nil) (assert (== b 11)))"))

{ a=10; if a > 9 56 else 67 } // okay
                              
// the lost else problem:

// this next omits the else terms when parsing, and the 2nd then.
// adding in the semi-colons manually fixes the lost else:
// works:
// { a = 10;  b = 0;  if a < 9 {    b++  } else {    b += 10  } ; (assert (== b 10))  ;  if a > 9 {    b++  };  (assert (== b 11)) }

(assert (== (str (infixExpand { a = 10;  b = 0;  if a < 9 {    b++  } else {    b += 10  } ; (assert (== b 10))  ;  if a > 9 {    b++  };  (assert (== b 11)) })) "(quote (set a 10) (set b 0) (cond (< a 9) (infix [b ++]) (infix [b += 10])) (assert (== b 10)) (cond (> a 9) (infix [b ++]) nil) (assert (== b 11)))"))
/*
// mis-parses, bad, lost else:
{ a = 10;  b = 0;  if a < 9 {    b++  } else {    b += 10  }  (assert (== b 10))  ;  if a > 9 {    b++  }  (assert (== b 11)) }

// reduced version
{ if a < 9 {    b++  } else {    b += 10  }  (assert (== b 10))  ;  if a > 9 {    b++  }  (assert (== b 11)) }


// parses okay with semicolons added:
{ a=10; b=0; if a < 9 {    b++  } else {    b += 10  };  (assert (== b 10))  ;  if a > 9 {    b++  };  (assert (== b 11)) }

// except that the if doesn't get turned into a cond.

// this next omits the else terms when parsing, or the 2nd then
{ a = 10;
  b = 0;
  if a < 9 {
    b++
  } else {
    b += 10
  }
  (assert (== b 10))
  ;
  if a > 9 {
    b++
  }
  (assert (== b 11))
}
*/

/*
Go's semicolon insertion rules:

a) When the input is broken into tokens, a semicolon is automatically inserted into the token stream at the end of a non-blank line if the line's final token is:

- an identifier or basic literal
- one of the keywords break, continue, fallthrough or return
    - one of the tokens ++ -- ) ] }

    When the input is broken into tokens, a semicolon is automatically inserted into the token stream at the end of a non-blank line if the line's final token is

    an identifier
    an integer, floating-point, imaginary, rune, or string literal
    one of the keywords break, continue, fallthrough, or return
    one of the operators and delimiters ++, --, ), ], or }
    To allow complex statements to occupy a single line, a semicolon may be omitted before a closing ")" or "}".
    
*/