// one can define a package directly, like this:
(def hi (package "hello"
   { World := "earth"; (defn Myfun [x] (concat World x)) }
))

(assert (== hi.World "earth"))
(assert (== (hi.Myfun "yes") "earthyes"))

// or one can define a package by sourcing another file:
{p = (package "doggerel" (source "tests/pkghelp"))}

(assert (== p.A.B 42))
(assert (== p.A.Dog "bella"))
(assert (== (p.A.F) 54)) // we can call functions
(assert (== (p.Assistor 9) (+ 9 42 3 7))) // functions can refer to package local values and functions

// and test importing pre-made packages:
{k := (source "tests/prepackage")}

(assert (== (k.Funky "yipee") "yipee roverDog chases cat"))
(assert (== k.Kit "cat"))

// package visibility rules like in Go: lowercase => private, Uppercase => Public.
(expectError "Error calling '+': Cannot access private member 'privetLane' of package 'helloKit'" (+ k.privetLane 1))

// check that visibility rules apply to imports of imports
//(def outer (package "outerSpace" (def inner (package "innerSpace" (source "tests/prepackage")))))
//(assert (== (outer.inner.Kit "cat")))
//(expectError "Cannot access private member 'privetLane' of package 'helloKit'" outer.inner.privetLane)

// verify no infinite loop on this...
// (def outer (package "outerSpace" (def inner (package "innerSpace" (source "prepackage")))))